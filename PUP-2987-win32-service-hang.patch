From 2cba5d376193f4a2853c08d4dfa96768cfacffe6 Mon Sep 17 00:00:00 2001
From: "Ethan J. Brown" <Iristyle@github>
Date: Wed, 13 Aug 2014 21:40:24 -0700
Subject: [PATCH 1/5] Allocate correct number of pointers for events

 - The FFI memory pointer initializer takes a count of the type it's
   allocating, not the number of total bytes
---
 lib/win32/daemon.rb | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/lib/win32/daemon.rb b/lib/win32/daemon.rb
index f141ccd..59d0b33 100644
--- a/lib/win32/daemon.rb
+++ b/lib/win32/daemon.rb
@@ -255,7 +255,7 @@ module Win32
         raise SystemCallError.new('CreateThread', FFI.errno)
       end
 
-      events = FFI::MemoryPointer.new(:pointer, FFI::Pointer.size*2)
+      events = FFI::MemoryPointer.new(:pointer, 2)
       events.put_pointer(0, FFI::Pointer.new(hThread))
       events.put_pointer(FFI::Pointer.size, FFI::Pointer.new(@@hStartEvent))
 
-- 
1.9.4.msysgit.0


From c0c7f808612b93b742502d1f0d33af08905276ae Mon Sep 17 00:00:00 2001
From: "Ethan J. Brown" <Iristyle@github>
Date: Wed, 13 Aug 2014 21:52:21 -0700
Subject: [PATCH 2/5] Prevent Daemon exceptions from deadlocking service

 - If any methods that respond to the SCM throw an exception, the
   @@hStopCompletedEvent is never signaled and the service can hang.
   This includes service_pause, service_resume, service_interrogate,
   service_shutdown, service_paramchange, service_netbindadd,
   service_netbindremove, service_netbindenable, service_netbinddisable,
   or service_stop.  Effectively, guard against user-defined classes
   derived from Win32::Daemon misbheaving and hanging the service.
---
 lib/win32/daemon.rb | 53 ++++++++++++++++++++++++++++-------------------------
 1 file changed, 28 insertions(+), 25 deletions(-)

diff --git a/lib/win32/daemon.rb b/lib/win32/daemon.rb
index 59d0b33..a407afd 100644
--- a/lib/win32/daemon.rb
+++ b/lib/win32/daemon.rb
@@ -272,33 +272,36 @@ module Win32
       end
 
       thr = Thread.new do
-        while(WaitForSingleObject(@@hStopEvent, 10) == WAIT_TIMEOUT)
-          # Check to see if anything interesting has been signaled
-          case @@waiting_control_code
-            when SERVICE_CONTROL_PAUSE
-              service_pause() if respond_to?('service_pause')
-            when SERVICE_CONTROL_CONTINUE
-              service_resume() if respond_to?('service_resume')
-            when SERVICE_CONTROL_INTERROGATE
-              service_interrogate() if respond_to?('service_interrogate')
-            when SERVICE_CONTROL_SHUTDOWN
-              service_shutdown() if respond_to?('service_shutdown')
-            when SERVICE_CONTROL_PARAMCHANGE
-              service_paramchange() if respond_to?('service_paramchange')
-            when SERVICE_CONTROL_NETBINDADD
-              service_netbindadd() if respond_to?('service_netbindadd')
-            when SERVICE_CONTROL_NETBINDREMOVE
-              service_netbindremove() if respond_to?('service_netbindremove')
-            when SERVICE_CONTROL_NETBINDENABLE
-              service_netbindenable() if respond_to?('service_netbindenable')
-            when SERVICE_CONTROL_NETBINDDISABLE
-              service_netbinddisable() if respond_to?('service_netbinddisable')
+        begin
+          while(WaitForSingleObject(@@hStopEvent, 10) == WAIT_TIMEOUT)
+            # Check to see if anything interesting has been signaled
+            case @@waiting_control_code
+              when SERVICE_CONTROL_PAUSE
+                service_pause() if respond_to?('service_pause')
+              when SERVICE_CONTROL_CONTINUE
+                service_resume() if respond_to?('service_resume')
+              when SERVICE_CONTROL_INTERROGATE
+                service_interrogate() if respond_to?('service_interrogate')
+              when SERVICE_CONTROL_SHUTDOWN
+                service_shutdown() if respond_to?('service_shutdown')
+              when SERVICE_CONTROL_PARAMCHANGE
+                service_paramchange() if respond_to?('service_paramchange')
+              when SERVICE_CONTROL_NETBINDADD
+                service_netbindadd() if respond_to?('service_netbindadd')
+              when SERVICE_CONTROL_NETBINDREMOVE
+                service_netbindremove() if respond_to?('service_netbindremove')
+              when SERVICE_CONTROL_NETBINDENABLE
+                service_netbindenable() if respond_to?('service_netbindenable')
+              when SERVICE_CONTROL_NETBINDDISABLE
+                service_netbinddisable() if respond_to?('service_netbinddisable')
+            end
+            @@waiting_control_code = IDLE_CONTROL_CODE
           end
-          @@waiting_control_code = IDLE_CONTROL_CODE
-        end
 
-        service_stop() if respond_to?('service_stop')
-        SetEvent(@@hStopCompletedEvent)
+          service_stop() if respond_to?('service_stop')
+        ensure
+          SetEvent(@@hStopCompletedEvent)
+        end
       end
 
       if respond_to?('service_main')
-- 
1.9.4.msysgit.0


From a22b95341f5ec306818b3c0fe59765f85c4f625d Mon Sep 17 00:00:00 2001
From: "Ethan J. Brown" <Iristyle@github>
Date: Wed, 13 Aug 2014 22:16:58 -0700
Subject: [PATCH 3/5] Use CreateThread user param for
 StartServiceCtrlDispatcher

 - The 4th parameter to the CreateThread function is an LPVOID that
   allows a user parameter to be passed to the newly created thread.
   Instead of using a Ruby closure over Service_Main within the
   ThreadProc (which could be considered a bit dangerous with respect
   go GC), perform a safer operation by passing a native pointer to
   the function.
---
 lib/win32/daemon.rb | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/lib/win32/daemon.rb b/lib/win32/daemon.rb
index a407afd..e21603c 100644
--- a/lib/win32/daemon.rb
+++ b/lib/win32/daemon.rb
@@ -184,7 +184,7 @@ module Win32
 
       s = SERVICE_TABLE_ENTRY.new(ste[0])
       s[:lpServiceName] = FFI::MemoryPointer.from_string('')
-      s[:lpServiceProc] = Service_Main
+      s[:lpServiceProc] = lpParameter
 
       s = SERVICE_TABLE_ENTRY.new(ste[1])
       s[:lpServiceName] = nil
@@ -249,7 +249,7 @@ module Win32
         raise SystemCallError.new('CreateEvent', FFI.errno)
       end
 
-      hThread = CreateThread(nil, 0, ThreadProc, nil, 0, nil)
+      hThread = CreateThread(nil, 0, ThreadProc, Service_Main, 0, nil)
 
       if hThread == 0
         raise SystemCallError.new('CreateThread', FFI.errno)
-- 
1.9.4.msysgit.0


From 76a6f2ca08617e5e84138cbc3034e2497b9858c3 Mon Sep 17 00:00:00 2001
From: "Ethan J. Brown" <Iristyle@github>
Date: Wed, 13 Aug 2014 22:57:52 -0700
Subject: [PATCH 4/5] Prevent Service_Main exceptions from deadlocking service

 - If the code within Service_Main throws an exception or otherwise
   exits prematurely, then the call will never be made to
   SetTheServiceStatus to tell the SCM that the service has successfully
   completed.  Without this notification sent to the SCM,
   StartServiceCtrlDispatcher will never return and the service will
   hang with a status of STOP_PENDING.
 - This exact behavior has been observed within the Ruby 2.0 x64
   environment, where due to unknown reasons, the Service_Main thread
   is prematurely terminated.  In this particular case, as soon as
   Service_Ctrl_ex is called by the SCM, Service_Main appears to die
   immediately.  In observed cases, there is some race condition
   present as the situation is not always reproducible.
---
 lib/win32/daemon.rb | 66 +++++++++++++++++++++++++++--------------------------
 1 file changed, 34 insertions(+), 32 deletions(-)

diff --git a/lib/win32/daemon.rb b/lib/win32/daemon.rb
index e21603c..39ffe12 100644
--- a/lib/win32/daemon.rb
+++ b/lib/win32/daemon.rb
@@ -137,46 +137,48 @@ module Win32
 
     # Called by the service control manager after the call to StartServiceCtrlDispatcher.
     Service_Main = FFI::Function.new(:void, [:ulong, :pointer], :blocking => false) do |dwArgc,lpszArgv|
-      # Obtain the name of the service.
-      if lpszArgv.address!=0
-        argv = lpszArgv.get_array_of_string(0,dwArgc)
-        lpszServiceName = argv[0]
-      else
-        lpszServiceName = ''
-      end
+      begin
+        # Obtain the name of the service.
+        if lpszArgv.address!=0
+          argv = lpszArgv.get_array_of_string(0,dwArgc)
+          lpszServiceName = argv[0]
+        else
+          lpszServiceName = ''
+        end
 
-      # Args passed to Service.start
-      if(dwArgc > 1)
-        @@Argv = argv[1..-1]
-      else
-        @@Argv = nil
-      end
+        # Args passed to Service.start
+        if(dwArgc > 1)
+          @@Argv = argv[1..-1]
+        else
+          @@Argv = nil
+        end
 
-      # Register the service ctrl handler.
-      @@ssh = RegisterServiceCtrlHandlerEx(
-        lpszServiceName,
-        Service_Ctrl_ex,
-        nil
-      )
+        # Register the service ctrl handler.
+        @@ssh = RegisterServiceCtrlHandlerEx(
+          lpszServiceName,
+          Service_Ctrl_ex,
+          nil
+        )
 
-      # No service to stop, no service handle to notify, nothing to do but exit.
-      return if @@ssh == 0
+        # No service to stop, no service handle to notify, nothing to do but exit.
+        return if @@ssh == 0
 
-      # The service has started.
-      SetTheServiceStatus.call(SERVICE_RUNNING, NO_ERROR, 0, 0)
+        # The service has started.
+        SetTheServiceStatus.call(SERVICE_RUNNING, NO_ERROR, 0, 0)
 
-      SetEvent(@@hStartEvent)
+        SetEvent(@@hStartEvent)
 
-      # Main loop for the service.
-      while(WaitForSingleObject(@@hStopEvent, 1000) != WAIT_OBJECT_0) do
-      end
+        # Main loop for the service.
+        while(WaitForSingleObject(@@hStopEvent, 1000) != WAIT_OBJECT_0) do
+        end
 
-      # Main loop for the service.
-      while(WaitForSingleObject(@@hStopCompletedEvent, 1000) != WAIT_OBJECT_0) do
+        # Main loop for the service.
+        while(WaitForSingleObject(@@hStopCompletedEvent, 1000) != WAIT_OBJECT_0) do
+        end
+      ensure
+        # Stop the service.
+        SetTheServiceStatus.call(SERVICE_STOPPED, NO_ERROR, 0, 0)
       end
-
-      # Stop the service.
-      SetTheServiceStatus.call(SERVICE_STOPPED, NO_ERROR, 0, 0)
     end
 
     ThreadProc = FFI::Function.new(:ulong,[:pointer]) do |lpParameter|
-- 
1.9.4.msysgit.0


From 215cfd49ffafc812d2f08764b310c2dadc60a23e Mon Sep 17 00:00:00 2001
From: "Ethan J. Brown" <Iristyle@github>
Date: Wed, 13 Aug 2014 23:05:04 -0700
Subject: [PATCH 5/5] Return correct codes from Service_Ctrl_Ex

 - According to the MSDN documentation for the HandlerEx function, it
   should geneally return NO_ERROR, or ERROR_CALL_NOT_IMPLEMENTED:
http://msdn.microsoft.com/en-us/library/windows/desktop/ms683241(v=vs.85).aspx
   Presently the return value from the HandlerEx function is whatever
   the return value happens to be from the SetTheServiceStatus function.
   This is technically not correct, and thus the code has been
   updated to reflect this.
---
 lib/win32/daemon.rb | 53 +++++++++++++++++++++++++++++++----------------------
 1 file changed, 31 insertions(+), 22 deletions(-)

diff --git a/lib/win32/daemon.rb b/lib/win32/daemon.rb
index 39ffe12..f8d7861 100644
--- a/lib/win32/daemon.rb
+++ b/lib/win32/daemon.rb
@@ -103,36 +103,45 @@ module Win32
       end
     end
 
+    ERROR_CALL_NOT_IMPLEMENTED = 0x78
+
     # Handles control signals from the service control manager.
     Service_Ctrl_ex = Proc.new do |dwCtrlCode,dwEventType,lpEventData,lpContext|
       @@waiting_control_code = dwCtrlCode;
+      return_value = NO_ERROR
 
-      dwState = SERVICE_RUNNING
-
-      case dwCtrlCode
-        when SERVICE_CONTROL_STOP
-          dwState = SERVICE_STOP_PENDING
-        when SERVICE_CONTROL_SHUTDOWN
-          dwState = SERVICE_STOP_PENDING
-        when SERVICE_CONTROL_PAUSE
-          dwState = SERVICE_PAUSED
-        when SERVICE_CONTROL_CONTINUE
-          dwState = SERVICE_RUNNING
-        #else
-          # TODO: Handle other control codes? Retain the current state?
-      end
+      begin
+        dwState = SERVICE_RUNNING
+
+        case dwCtrlCode
+          when SERVICE_CONTROL_STOP
+            dwState = SERVICE_STOP_PENDING
+          when SERVICE_CONTROL_SHUTDOWN
+            dwState = SERVICE_STOP_PENDING
+          when SERVICE_CONTROL_PAUSE
+            dwState = SERVICE_PAUSED
+          when SERVICE_CONTROL_CONTINUE
+            dwState = SERVICE_RUNNING
+          #else
+            # TODO: Handle other control codes? Retain the current state?
+        end
 
-      # Set the status of the service except on interrogation.
-      unless dwCtrlCode == SERVICE_CONTROL_INTERROGATE
-        SetTheServiceStatus.call(dwState, NO_ERROR, 0, 0)
-      end
+        # Set the status of the service except on interrogation.
+        unless dwCtrlCode == SERVICE_CONTROL_INTERROGATE
+          SetTheServiceStatus.call(dwState, NO_ERROR, 0, 0)
+        end
 
-      # Tell service_main thread to stop.
-      if dwCtrlCode == SERVICE_CONTROL_STOP || dwCtrlCode == SERVICE_CONTROL_SHUTDOWN
-        if !SetEvent(@@hStopEvent)
-          SetTheServiceStatus.call(SERVICE_STOPPED, FFI.errno, 0, 0)
+        # Tell service_main thread to stop.
+        if dwCtrlCode == SERVICE_CONTROL_STOP || dwCtrlCode == SERVICE_CONTROL_SHUTDOWN
+          if SetEvent(@@hStopEvent) == 0
+            SetTheServiceStatus.call(SERVICE_STOPPED, FFI.errno, 0, 0)
+          end
         end
+      rescue
+        return_value = ERROR_CALL_NOT_IMPLEMENTED
       end
+
+      return_value
     end
 
     # Called by the service control manager after the call to StartServiceCtrlDispatcher.
-- 
1.9.4.msysgit.0

